# 期权回测实现步骤详解

## 📋 目录

1. [回测系统架构](#回测系统架构)
2. [核心实现步骤](#核心实现步骤)
3. [数据流程](#数据流程)
4. [关键算法](#关键算法)
5. [使用示例](#使用示例)
6. [性能优化](#性能优化)

---

## 回测系统架构

### 系统组件

```
┌─────────────────────────────────────────────────────────┐
│                    回测系统架构                          │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────┐      ┌──────────────┐                │
│  │  前端界面    │─────▶│  API接口     │                │
│  │ (React)      │      │ (FastAPI)    │                │
│  └──────────────┘      └──────┬───────┘                │
│                               │                          │
│                               ▼                          │
│                    ┌──────────────────┐                 │
│                    │  BacktestEngine  │                 │
│                    │   (回测引擎)      │                 │
│                    └────────┬─────────┘                 │
│                             │                            │
│              ┌──────────────┼──────────────┐            │
│              ▼              ▼              ▼            │
│     ┌────────────┐  ┌────────────┐  ┌────────────┐    │
│     │ Options    │  │ Historical │  │ Portfolio  │    │
│     │ Engine     │  │ Data Mgr   │  │ Manager    │    │
│     │(定价引擎)  │  │(历史数据)  │  │(组合管理)  │    │
│     └────────────┘  └────────────┘  └────────────┘    │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 核心类说明

1. **BacktestEngine** - 回测引擎主类
   - 负责整个回测流程的协调
   - 管理时间循环和事件处理
   - 计算绩效指标

2. **OptionsEngine** - 期权定价引擎
   - Black-Scholes模型定价
   - 希腊字母计算
   - 隐含波动率计算

3. **HistoricalDataManager** - 历史数据管理器
   - 加载历史期权数据
   - 数据缓存和查询
   - 数据质量检查

4. **Portfolio** - 投资组合管理
   - 持仓管理
   - 现金流管理
   - 盈亏计算

---

## 核心实现步骤

### 步骤1: 初始化回测引擎

```python
from src.backtest.backtest_engine import BacktestEngine
from src.pricing.options_engine import OptionsEngine
from src.historical.manager import HistoricalDataManager

# 创建定价引擎
pricing_engine = OptionsEngine()

# 创建历史数据管理器（可选）
historical_manager = HistoricalDataManager(
    db_path="data/historical.db",
    cache_size_mb=200
)

# 创建回测引擎
backtest_engine = BacktestEngine(
    options_engine=pricing_engine,
    use_historical_data=True,  # 使用历史数据
    historical_data_manager=historical_manager
)
```

**关键参数**：
- `use_historical_data`: 是否使用真实历史数据（False则使用模拟数据）
- `historical_data_manager`: 历史数据管理器实例

### 步骤2: 准备策略

```python
from src.strategy.strategy_manager import StrategyManager
from src.core.models import OptionType
from datetime import datetime, timedelta
from decimal import Decimal

# 创建策略管理器
strategy_manager = StrategyManager()

# 创建策略（以跨式策略为例）
expiry = datetime.now() + timedelta(days=30)
strategy = strategy_manager.create_straddle(
    strike=Decimal("50000"),
    expiry=expiry,
    quantity=1,
    long=True  # 多头跨式
)
```

**支持的策略类型**：
- `create_single_leg_strategy()` - 单腿策略
- `create_straddle()` - 跨式策略
- `create_strangle()` - 宽跨式策略
- `create_iron_condor()` - 铁鹰策略
- `create_butterfly()` - 蝶式策略

### 步骤3: 设置回测参数

```python
# 回测时间范围
start_date = datetime(2024, 1, 1)
end_date = datetime(2024, 3, 31)

# 初始资金
initial_capital = Decimal("100000")

# 标的资产
underlying_symbol = "BTC"
```

### 步骤4: 运行回测

```python
# 执行回测
result = await backtest_engine.run_backtest(
    strategy=strategy,
    start_date=start_date,
    end_date=end_date,
    initial_capital=initial_capital,
    underlying_symbol=underlying_symbol
)
```

### 步骤5: 分析结果

```python
# 打印基本指标
print(f"策略名称: {result.strategy_name}")
print(f"初始资金: ${result.initial_capital:,.2f}")
print(f"最终资金: ${result.final_capital:,.2f}")
print(f"总收益率: {result.total_return:.2%}")
print(f"夏普比率: {result.sharpe_ratio:.2f}")
print(f"最大回撤: {result.max_drawdown:.2%}")
print(f"胜率: {result.win_rate:.2%}")
print(f"总交易次数: {result.total_trades}")

# 查看交易记录
for trade in result.trades:
    print(f"{trade.timestamp} | {trade.action} | "
          f"{trade.option_contract.instrument_name} | "
          f"数量: {trade.quantity} | 价格: ${trade.price} | "
          f"盈亏: ${trade.pnl}")

# 查看每日盈亏
for daily in result.daily_pnl:
    print(f"{daily.date} | 组合价值: ${daily.portfolio_value:,.2f} | "
          f"当日盈亏: ${daily.daily_pnl:,.2f} | "
          f"累计盈亏: ${daily.cumulative_pnl:,.2f}")
```

---

## 数据流程

### 完整回测流程图

```
开始回测
    │
    ▼
┌─────────────────────┐
│ 1. 加载历史数据     │
│   - 期权价格        │
│   - 标的价格        │
│   - 隐含波动率      │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│ 2. 建立初始仓位     │
│   - 根据策略腿      │
│   - 计算初始成本    │
│   - 更新现金余额    │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│ 3. 时间循环开始     │◄──────┐
│   (每日更新)        │       │
└──────┬──────────────┘       │
       │                       │
       ▼                       │
┌─────────────────────┐       │
│ 4. 更新期权价格     │       │
│   - 从历史数据获取  │       │
│   - 或使用BS模型    │       │
└──────┬──────────────┘       │
       │                       │
       ▼                       │
┌─────────────────────┐       │
│ 5. 应用时间衰减     │       │
│   - Theta衰减       │       │
└──────┬──────────────┘       │
       │                       │
       ▼                       │
┌─────────────────────┐       │
│ 6. 检查期权到期     │       │
│   - 计算到期价值    │       │
│   - 平仓到期期权    │       │
└──────┬──────────────┘       │
       │                       │
       ▼                       │
┌─────────────────────┐       │
│ 7. 更新组合价值     │       │
│   - 持仓市值        │       │
│   - 现金余额        │       │
└──────┬──────────────┘       │
       │                       │
       ▼                       │
┌─────────────────────┐       │
│ 8. 记录每日盈亏     │       │
│   - 当日盈亏        │       │
│   - 累计盈亏        │       │
└──────┬──────────────┘       │
       │                       │
       ▼                       │
   日期+1 ──────────────────────┘
       │
       ▼
   到达结束日期？
       │
       ▼ 是
┌─────────────────────┐
│ 9. 平仓所有持仓     │
│   - 计算最终盈亏    │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│ 10. 计算绩效指标    │
│   - 总收益率        │
│   - 夏普比率        │
│   - 最大回撤        │
│   - 胜率            │
└──────┬──────────────┘
       │
       ▼
   返回回测结果
```

### 价格更新逻辑

```python
def _update_option_prices(self, portfolio, current_date):
    """更新期权价格的详细流程"""
    
    # 1. 获取标的价格
    if self.use_historical_data:
        # 从历史数据获取
        underlying_price = self._get_underlying_price_from_data(current_date)
    else:
        # 使用固定价格
        underlying_price = 50000.0
    
    # 2. 遍历所有持仓
    for position in portfolio.positions:
        option = position.option_contract
        
        # 3. 计算到期时间
        time_to_expiry = (option.expiration_date - current_date).days / 365.0
        
        if time_to_expiry > 0:
            # 4. 尝试从历史数据获取价格
            if self.use_historical_data:
                historical_price = self._get_option_price_from_data(
                    option.instrument_name,
                    current_date
                )
                
                if historical_price is not None:
                    # 使用历史价格
                    option.current_price = historical_price
                    # 继续下一个期权
                    continue
            
            # 5. 使用Black-Scholes模型定价（回退方案）
            bs_price = self.options_engine.black_scholes_price(
                S=underlying_price,
                K=float(option.strike_price),
                T=time_to_expiry,
                r=0.05,  # 无风险利率
                sigma=option.implied_volatility,
                option_type=option.option_type
            )
            
            option.current_price = Decimal(str(bs_price))
            
            # 6. 计算希腊字母
            greeks = self.options_engine.calculate_greeks(
                S=underlying_price,
                K=float(option.strike_price),
                T=time_to_expiry,
                r=0.05,
                sigma=option.implied_volatility,
                option_type=option.option_type
            )
            
            option.delta = greeks.delta
            option.gamma = greeks.gamma
            option.theta = greeks.theta
            option.vega = greeks.vega
            option.rho = greeks.rho
        
        # 7. 更新持仓价值和未实现盈亏
        position.current_value = option.current_price
        if position.quantity > 0:
            position.unrealized_pnl = (
                (option.current_price - position.entry_price) * 
                Decimal(position.quantity)
            )
        else:
            position.unrealized_pnl = (
                (position.entry_price - option.current_price) * 
                Decimal(abs(position.quantity))
            )
```

---

## 关键算法

### 1. Black-Scholes期权定价

```python
def black_scholes_price(self, S, K, T, r, sigma, option_type):
    """
    Black-Scholes期权定价公式
    
    参数:
        S: 标的资产当前价格
        K: 执行价格
        T: 到期时间（年）
        r: 无风险利率
        sigma: 波动率
        option_type: 期权类型（CALL/PUT）
    """
    from scipy.stats import norm
    import numpy as np
    
    # 计算d1和d2
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    
    if option_type == OptionType.CALL:
        # 看涨期权价格
        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    else:
        # 看跌期权价格
        price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    
    return price
```

### 2. 希腊字母计算

```python
def calculate_greeks(self, S, K, T, r, sigma, option_type):
    """
    计算期权希腊字母
    
    返回:
        Greeks对象，包含delta, gamma, theta, vega, rho
    """
    from scipy.stats import norm
    import numpy as np
    
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    
    # Delta - 价格变化敏感度
    if option_type == OptionType.CALL:
        delta = norm.cdf(d1)
    else:
        delta = norm.cdf(d1) - 1
    
    # Gamma - Delta变化率
    gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))
    
    # Theta - 时间价值衰减
    if option_type == OptionType.CALL:
        theta = (
            -S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) -
            r * K * np.exp(-r * T) * norm.cdf(d2)
        ) / 365
    else:
        theta = (
            -S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) +
            r * K * np.exp(-r * T) * norm.cdf(-d2)
        ) / 365
    
    # Vega - 波动率敏感度
    vega = S * norm.pdf(d1) * np.sqrt(T) / 100
    
    # Rho - 利率敏感度
    if option_type == OptionType.CALL:
        rho = K * T * np.exp(-r * T) * norm.cdf(d2) / 100
    else:
        rho = -K * T * np.exp(-r * T) * norm.cdf(-d2) / 100
    
    return Greeks(
        delta=delta,
        gamma=gamma,
        theta=theta,
        vega=vega,
        rho=rho
    )
```

### 3. 夏普比率计算

```python
def _calculate_sharpe_ratio(self, daily_pnl):
    """
    计算夏普比率
    
    夏普比率 = (平均收益率 - 无风险利率) / 收益率标准差
    """
    import numpy as np
    
    # 计算每日收益率
    returns = []
    for i in range(1, len(daily_pnl)):
        prev_value = daily_pnl[i-1].portfolio_value
        curr_value = daily_pnl[i].portfolio_value
        if prev_value > 0:
            daily_return = float((curr_value - prev_value) / prev_value)
            returns.append(daily_return)
    
    if not returns:
        return 0.0
    
    # 计算平均收益率和标准差
    mean_return = np.mean(returns)
    std_return = np.std(returns)
    
    if std_return == 0:
        return 0.0
    
    # 年化夏普比率
    # 假设无风险利率为0（简化）
    sharpe_ratio = (mean_return * np.sqrt(252)) / std_return
    
    return float(sharpe_ratio)
```

### 4. 最大回撤计算

```python
def _calculate_max_drawdown(self, daily_pnl):
    """
    计算最大回撤
    
    最大回撤 = (峰值 - 谷底) / 峰值
    """
    portfolio_values = [float(pnl.portfolio_value) for pnl in daily_pnl]
    
    max_drawdown = 0.0
    peak = portfolio_values[0]
    
    for value in portfolio_values:
        # 更新峰值
        if value > peak:
            peak = value
        
        # 计算当前回撤
        drawdown = (peak - value) / peak if peak > 0 else 0.0
        
        # 更新最大回撤
        max_drawdown = max(max_drawdown, drawdown)
    
    return max_drawdown
```

---

## 使用示例

### 示例1: 简单的看涨期权回测

```python
import asyncio
from datetime import datetime, timedelta
from decimal import Decimal
from src.backtest.backtest_engine import BacktestEngine
from src.strategy.strategy_manager import StrategyManager
from src.core.models import OptionType

async def simple_call_backtest():
    # 创建策略
    strategy_manager = StrategyManager()
    strategy = strategy_manager.create_single_leg_strategy(
        option_type=OptionType.CALL,
        action="buy",
        strike=Decimal("50000"),
        expiry=datetime.now() + timedelta(days=30),
        quantity=1
    )
    
    # 创建回测引擎
    engine = BacktestEngine(use_historical_data=False)
    
    # 运行回测
    result = await engine.run_backtest(
        strategy=strategy,
        start_date=datetime.now(),
        end_date=datetime.now() + timedelta(days=15),
        initial_capital=Decimal("10000")
    )
    
    # 打印结果
    print(f"总收益率: {result.total_return:.2%}")
    print(f"夏普比率: {result.sharpe_ratio:.2f}")
    print(f"最大回撤: {result.max_drawdown:.2%}")

# 运行
asyncio.run(simple_call_backtest())
```

### 示例2: 使用历史数据的跨式策略回测

```python
async def straddle_with_historical_data():
    from src.historical.manager import HistoricalDataManager
    
    # 创建历史数据管理器
    historical_manager = HistoricalDataManager(
        db_path="data/historical.db"
    )
    
    # 创建回测引擎（使用历史数据）
    engine = BacktestEngine(
        use_historical_data=True,
        historical_data_manager=historical_manager
    )
    
    # 创建跨式策略
    strategy_manager = StrategyManager()
    strategy = strategy_manager.create_straddle(
        strike=Decimal("50000"),
        expiry=datetime(2024, 2, 29),
        quantity=1,
        long=True
    )
    
    # 运行回测
    result = await engine.run_backtest(
        strategy=strategy,
        start_date=datetime(2024, 1, 1),
        end_date=datetime(2024, 1, 31),
        initial_capital=Decimal("20000"),
        underlying_symbol="BTC"
    )
    
    print(f"使用历史数据回测")
    print(f"总收益率: {result.total_return:.2%}")
    print(f"夏普比率: {result.sharpe_ratio:.2f}")

asyncio.run(straddle_with_historical_data())
```

### 示例3: 批量回测多个策略

```python
async def batch_backtest():
    engine = BacktestEngine()
    strategy_manager = StrategyManager()
    
    # 创建多个策略
    strategies = [
        strategy_manager.create_single_leg_strategy(
            OptionType.CALL, "buy", Decimal("50000"), 
            datetime.now() + timedelta(days=30), 1
        ),
        strategy_manager.create_straddle(
            Decimal("50000"), datetime.now() + timedelta(days=30), 1, True
        ),
        strategy_manager.create_strangle(
            Decimal("52000"), Decimal("48000"), 
            datetime.now() + timedelta(days=30), 1, True
        )
    ]
    
    # 批量回测
    results = []
    for strategy in strategies:
        result = await engine.run_backtest(
            strategy=strategy,
            start_date=datetime.now(),
            end_date=datetime.now() + timedelta(days=20),
            initial_capital=Decimal("20000")
        )
        results.append(result)
    
    # 比较结果
    print("策略比较:")
    for result in results:
        print(f"{result.strategy_name}: {result.total_return:.2%}")

asyncio.run(batch_backtest())
```

---

## 性能优化

### 1. 数据缓存

```python
# 使用LRU缓存减少重复计算
from functools import lru_cache

@lru_cache(maxsize=1000)
def cached_black_scholes_price(S, K, T, r, sigma, option_type):
    """缓存BS定价结果"""
    return black_scholes_price(S, K, T, r, sigma, option_type)
```

### 2. 批量计算

```python
# 批量更新所有期权价格
def batch_update_prices(self, positions, current_date):
    """批量更新，减少循环开销"""
    underlying_price = self._get_underlying_price(current_date)
    
    # 一次性计算所有期权
    for position in positions:
        # ... 更新逻辑
```

### 3. 并行回测

```python
import asyncio

async def parallel_backtest(strategies):
    """并行运行多个回测"""
    tasks = [
        engine.run_backtest(strategy, start, end, capital)
        for strategy in strategies
    ]
    results = await asyncio.gather(*tasks)
    return results
```

### 4. 内存优化

```python
# 只保留必要的历史数据
class BacktestDataSet:
    def __init__(self, max_memory_mb=200):
        self.max_memory = max_memory_mb * 1024 * 1024
        self.data = {}
    
    def add_data(self, key, value):
        # 检查内存使用
        if self._get_memory_usage() > self.max_memory:
            self._evict_old_data()
        self.data[key] = value
```

---

## 总结

期权回测的核心步骤：

1. **初始化** - 创建回测引擎和策略
2. **数据准备** - 加载历史数据或使用模拟数据
3. **建仓** - 根据策略建立初始持仓
4. **时间循环** - 每日更新价格、计算盈亏
5. **平仓** - 到期或结束时平仓
6. **分析** - 计算绩效指标

关键技术：
- Black-Scholes模型定价
- 希腊字母计算
- 时间价值衰减
- 绩效指标计算

当前系统支持：
- ✅ 多种策略类型
- ✅ 历史数据和模拟数据
- ✅ 完整的绩效分析
- ✅ 交易记录追踪

未来改进：
- 🔄 更准确的市场模型
- 🔄 滑点和流动性模拟
- 🔄 实时数据集成
- 🔄 机器学习优化
